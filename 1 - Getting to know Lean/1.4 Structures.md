# Structures

Em Lean podemos definir uma estrutura da seguinte maneira. Pense que estamos definindo um sistema Cartesiano onde temos X e Y ambos float.
```lean
structure Point where
    x : Float
    y : Float
deriving Repr
```
Após essa declaração `Point` é um novo tipo de estrutura. A ultima linha onde falamos `deriving Repr` pede ao Lean para gerar displey de códigos do tipo `Point`. Esse código é usado pelo `#eval` para renderizar o resultado de uma avaliação para consumo dos devs (A.K.A nós), como a função `repr` em Python. Também é possível substituir o código de exibição gerado pelo compilador.

O modo tipico de criarmos um valor para uma estrutura é provermos todos os valores que ela pede entre chaves, algo como:
```lean
def origin : Point := { x := 0.0, y := 0.0 }
```

Quando vamos evaluar o resultado de origin veremos algo como:
```lean
{ x := 0.000000, y := 0.000000 }
```
Porque structs existem para embrulharmos uma coleção de dados, nomeando-as e as tratando como uma simples unidade, isso também é importante porque nos possibilita extrair valores individuais de uma struct. Isso é feito utilizando o . como em C, Python e Rust.
```lean
#eval origin.x
```
```lean
0.000000
```
Isso pode ser usado para definir funções que recebem structs como argumentos. Por exemplo, adição de pontos é performada pela soma de valores subjacentes de uma cordenada. É o caso de `#eval addPoints { x := 1.5, y := 32 } { x := -8, y:= 0.2 }` retorna:
```lean
{ x := -6.500000, y := 32.200000 }
```
A função pega dois `Point` como argumentos chamados de `p1` e `p2`. O resultado é baseado na soma de dos valores de x e y de ambos os `Point`
```lean
def addPoints (p1 : Point) (p2 : Point) : Point :=
    { x := p1.x + p2.x, y := p1.y + p2.y }
```

Muitas structs terão fields que compartilharão o mesmo nome. Por exemplo um Ponto Tri-dimensional compartilha o nome dos fields `x` e `y`.
```lean
structure Point3D where
    x : Float
    y : Float
    z : Float
deriving Repr

def origin3D : Point3D := { x := 0, y := 0, z := 0 }
```

Isso significa que o tipo esperado a ser checado deve ser um tipo conhecido pelo Lean, caso o contrario ele não conseguirá checar. Por exemplo:
```lean
#check { x := 0, y := 0 }
```
Nos mostra um erro de:
```lean
invalid {...} notation, expected type is not knownLean 4
```
Como esperado podemos contornar isso sinalizando o tipo que queremos checar, algo como:
```lean
#check ({ x := 0, y := 0} : Point)
```
Para deixar os programas mais concisos Lean permite que façamos isso dentro das {} sem precisarmos de ()
```lean
#check { x := 0, y := 0 : Point }
```


# Updating Structures

